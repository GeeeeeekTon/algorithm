 其实我们关注的锁，是一个对象，这里就叫锁对象吧。我们知道，用synchronized修饰实例方法的话，就相当于synchronized(this)；

 修饰静态方法的话，
        就相当于synchronized(this.class)。可见，synchronized相关的代码最后都可以归结为是synchronized(Object)的形式，
        那么这个Object其实就是锁对象。
       一般锁对象可以是我们要访问的共享资源对象本身，也可以是专门定义的一个锁对象，总之得是一个公共的对象，
       所有访问其保护资源的线程都能访问到的对象。

        Java中提供了哪些锁？
               synchronized：(JVM)
               内置锁，可重入。内部做了一些细致的优化，获取锁过程为：偏向锁->轻量级锁->自旋锁->重量级锁。
               ReentrantLock：(JDK)
               基于AQS的可重入锁，比synchronized更加灵活。
               ReentrantReadWriteLock：
               基于AQS的可重入的读写锁。 继承ReadWriteLOCK
               SequenceLock：
               基于AQS的可重入的顺序锁，在乐观读方法上要比ReentrantReadWriteLock高效一些。(这个类在jsr166e的extra包里发现，但貌似没出现在jdk里)
               StampedLock：
               不可重入的优化读写锁，针对乐观读做了优化，一般用于构建内部并发组件。
               cas：
               程序中可以通过CAS操作来构建一些锁，比如jdk1.7中ForkJoin框架中使用的scanGuard包含的顺序锁、jdk1.8中Striped64的cellsBusy锁等。
               基于AQS构建的同步机制：
               这些同步机制和锁机制也有着很多联系。

            http://www.tuicool.com/articles/NnQjyq

    什么是可重入锁 ：可重入锁的概念是自己可以再次获取自己的内部锁。举个例子，比如一条线程获得了某个对象的锁，
    此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的（如果不可重入的锁的话，此刻会造成死锁）。
    说的更高深一点可重入锁是一种递归无阻塞的同步机制。

    什么叫读写锁 ：读写锁拆成读锁和写锁来理解。读锁可以共享，多个线程可以同时拥有读锁，但是写锁却只能只有一个线程拥有，
    而且获取写锁的时候其他线程都已经释放了读锁，而且该线程获取写锁之后，其他线程不能再获取读锁。简单的说就是写锁是排他锁，读锁是共享锁。

    获取锁涉及到的两个概念即 公平和非公平 ：公平表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO顺序。
    而非公平就是一种获取锁的抢占机制，和公平相对就是先来不一定先得，这个方式可能造成某些线程饥饿（一直拿不到锁）。

偏向锁
偏向锁(Biased Lock)主要解决无竞争下的锁性能问题
现在几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住/解锁监视对象，
按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，
因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，
说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。
Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。

偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会尝试消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
(偏向锁只能在单线程下起作用)
因此 流程是这样的 偏向锁->轻量级锁->重量级锁

下面这3个方法是CountDownLatch类中最重要的方法：
    public void await() throws InterruptedException { };   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
    public void countDown() { };  //将count值减1
